#lang racket
;; Metacircular evaluator, Chapter 4 SICP

; capture native apply, see footnote 15
(require (only-in racket (apply apply-in-underlying-scheme)))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type: EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type: APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))

(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env) env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
    (eval (definition-value exp) env) env)
  'ok)


;; 4.1.2 Representing expressions
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

(define (variable? exp) (symbol? exp))

(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))

(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))

(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))

(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))

(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))

(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? exp) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))

(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                            ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last: COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))



;; 4.1.3 Evaluator Data Structures
(define (true? x) (not (eq? x false)))
(define (false? x) (eq? x false))

(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

;; Unlike Scheme, Racket distinguishes mutable pairs/lists from
;; immutable counterparts. The environment/frame implementation relies
;; on mutability, so use mlists in these.
(require compatibility/mlist)

(define (enclosing-environment env) (mcdr env))
(define (first-frame env) (mcar env))
(define the-empty-environment '())

(define (make-frame variables values)
  (mcons variables values))
(define (frame-variables frame) (mcar frame))
(define (frame-values frame) (mcdr frame))
(define (add-binding-to-frame! var val frame)
  (set-mcar! frame (mcons var (mcar frame)))
  (set-mcdr! frame (mcons val (mcdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (mlength vars) (mlength vals))
      (mcons (make-frame vars vals) base-env)
      (if (< (mlength vars) (mlength vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (mcar vars)) (mcar vals))
            (else (scan (mcdr vars) (mcdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (mcar vars)) (set-mcar! vals val))
            (else (scan (mcdr vars) (mcdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (mcar vars)) (set-mcar! vals val))
            (else (scan (mcdr vars) (mcdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))


;; 4.1.4 Running the evaluator as a program

;; procedures from R5RS Scheme standard
(define primitive-procedures
  (list
   ;; 6.1 Equivalence predicates
   (list 'eqv? eqv?)
   (list 'eq? eq?)
   (list 'equal? equal?)
   ;; 6.2.1 Numerical types
   (list 'number? number?)
   (list 'complex? complex?)
   (list 'real? real?)
   (list 'rational? rational?)
   (list 'integer? integer?)
   (list 'exact? exact?)
   (list 'inexact? inexact?)
   (list '= =)
   (list '< <)
   (list '> >)
   (list '<= <=)
   (list '>= >=)
   (list 'zero? zero?)
   (list 'positive? positive?)
   (list 'negative? negative?)
   (list 'odd? odd?)
   (list 'even? even?)
   (list 'max max)
   (list 'min min)
   (list '+ +)
   (list '* *)
   (list '- -)
   (list '/ /)
   (list 'abs abs)
   (list 'quotient quotient)
   (list 'remainder remainder)
   (list 'modulo modulo)
   (list 'gcd gcd)
   (list 'lcm lcm)
   (list 'numerator numerator)
   (list 'denominator denominator)
   (list 'floor floor)
   (list 'ceiling ceiling)
   (list 'truncate truncate)
   (list 'round round)
   (list 'rationalize rationalize)
   (list 'exp exp)
   (list 'log log)
   (list 'sin sin)
   (list 'cos cos)
   (list 'tan tan)
   (list 'asin asin)
   (list 'acos acos)
   (list 'atan atan)
   (list 'sqrt sqrt)
   (list 'expt expt)
   (list 'make-rectangular make-rectangular)
   (list 'make-polar make-polar)
   (list 'real-part real-part)
   (list 'imag-part imag-part)
   (list 'magnitude magnitude)
   (list 'angle angle)
   (list 'exact->inexact exact->inexact)
   (list 'inexact->exact inexact->exact)
   (list 'number->string number->string)
   (list 'string->number string->number)
   ;; 6.3.1 Booleans
   (list 'boolean? boolean?)
   (list 'not not)
   ;; 6.3.2 Pairs and lists
   (list 'pair? pair?)
   (list 'cons cons)
   (list 'car car)
   (list 'cdr cdr)
   ;;(list 'set-car! set-car!)
   ;;(list 'set-cdr! set-cdr!)
   (list 'caar caar)
   (list 'cadr cadr)
   (list 'cddr cddr)
   (list 'caaar caaar)
   (list 'caadr caadr)
   (list 'cadar cadar)
   (list 'cdaar cdaar)
   (list 'caddr caddr)
   (list 'cddar cddar)
   (list 'cdadr cdadr)
   (list 'cdddr cdddr)
   (list 'caaaar caaaar)
   (list 'caaadr caaadr)
   (list 'caadar caadar)
   (list 'cadaar cadaar)
   (list 'cdaaar cdaaar)
   (list 'caaddr caaddr)
   (list 'caddar caddar)
   (list 'cddaar cddaar)
   (list 'cadadr cadadr)
   (list 'cdaadr cdaadr)
   (list 'cdadar cdadar)
   (list 'cadddr cadddr)
   (list 'cdddar cdddar)
   (list 'cddadr cddadr)
   (list 'cdaddr cddadr)
   (list 'cddddr cddddr)
   (list 'null? null?)
   (list 'list? list?)
   (list 'list list)
   (list 'length length)
   (list 'append append)
   (list 'reverse reverse)
   (list 'list-tail list-tail)
   (list 'list-ref list-ref)
   (list 'memq memq)
   (list 'memv memv)
   (list 'member member)
   (list 'assq assq)
   (list 'assv assv)
   (list 'assoc assoc)
   ;; 6.3.3 Symbols
   (list 'symbol? symbol?)
   (list 'symbol->string symbol->string)
   (list 'string->symbol string->symbol)
   ;; 6.3.4 Characters TODO
   (list 'char? char?)
   ;; 6.3.5 Strings
   (list 'string? string?)
   (list 'make-string make-string)
   (list 'string string)
   (list 'string-length string-length)
   (list 'string-ref string-ref)
   (list 'string-set! string-set!)
   (list 'string=? string=?)
   (list 'string-ci=? string-ci=?)
   (list 'string<? string<?)
   (list 'string>? string>?)
   (list 'string<=? string<=?)
   (list 'string>=? string>=?)
   (list 'string-ci<? string-ci<?)
   (list 'string-ci>? string-ci>?)
   (list 'string-ci<=? string-ci<=?)
   (list 'string-ci>=? string-ci>=?)
   (list 'substring substring)
   (list 'string-append string-append)
   (list 'string->list string->list)
   (list 'list->string list->string)
   (list 'string-copy string-copy)
   (list 'string-fill! string-fill!)
   ;; 6.3.6 Vectors
   (list 'vector? vector?)
   (list 'make-vector make-vector)
   (list 'vector vector)
   (list 'vector-length vector-length)
   (list 'vector-ref vector-ref)
   (list 'vector->list vector->list)
   (list 'list->vector list->vector)
   (list 'vector-fill! vector-fill!)
   ;; 6.4 Control features
   (list 'procedure? procedure?)
   (list 'apply apply)
   (list 'map map)
   (list 'for-each for-each)
   (list 'force force)
   (list 'call-with-current-continuation call-with-current-continuation)
   (list 'values values)
   (list 'call-with-values call-with-values)
   (list 'dynamic-wind dynamic-wind)
   (list 'eval eval)
   ;;(list 'scheme-report-environment scheme-report-environment)
   ;;(list 'null-environment null-environment)
   ;; 6.6.1 Ports TODO
   (list 'port? port?)
   ;;(list 'call-with-input-file call-with-input-file)
   ;;(list 'call-with-output-file call-with-output-file)
   ;;(list 'input-port? input-port?)
   ;;(list 'output-port? output-port?)
   ;; 6.6.2 Input
   (list 'read read)
   (list 'read-char read-char)
   (list 'peek-char peek-char)
   (list 'eof-object? eof-object?)
   (list 'char-ready? char-ready?)
   ;; 6.6.3 Output
   (list 'write write)
   (list 'display display)
   (list 'newline newline)
   (list 'write-char write-char)))

(define (primitive-procedure-names)
  (list->mlist
   (map car primitive-procedures)))
(define (primitive-procedure-objects)
  (list->mlist
   (map (lambda (proc) (list 'primitive (cadr proc)))
        primitive-procedures)))

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define the-global-environment (setup-environment))

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;; driver
(define input-prompt  ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure?
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

(provide (all-defined-out))
